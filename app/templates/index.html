<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Peel Explorer Express</title>
    <link rel="stylesheet" type="text/css" href="/static/css/clusterize.css">
</head>

<style>
    .networkCanvasContainer {
        float: left;
        width: 700px;
        height: 700px;
        margin-top: 5px;
        border: 1px solid lightgray;
        resize: both;
        overflow: hidden;
    }

    #networkCanvas {
        width: 98%;
        height: 98%;
        margin: 5px;
    }

    #bccTreeCanvas {
        width: 98%;
        height: 98%;
        margin: 5px;
    }

    #htreeContainer {
        float: left;
        width: 960px;
    }

    #hierarchyTree {
        width: 800px;
        height: 400px;
        /*margin: 10px;*/
        margin-right: 10px;
        overflow: auto;
        float: left;
        border: 1px solid lightgray;
    }

    #htreeManipulationControls {
        float: left;
        margin-left: 5px;
        height: 400px;
    }

    #htreeNodeChildrenDistributionChart {
        float: left;
        clear: both;
        width: 800px;
        height: 200px;
        border: 1px solid lightgray;
    }

    .collapsibleList li {
        list-style-image : url('/static/css/button.png');
        cursor: pointer;
    }

    li.collapsibleListOpen {
        list-style-image : url('/static/css/button-open.png');
        cursor: pointer;
    }

    li.collapsibleListClosed {
        list-style-image : url('/static/css/button-closed.png');
        cursor: pointer;
    }

    button {margin-bottom: 5px; margin-top: 5px;}

    td {border: 1px #DDD solid; padding: 5px; cursor: pointer;}

    .selected {
        background-color: gray !important;
        /*color: #FFF;*/
    }

    .canvasContainers {
        float: left;
    }

    #nodeInfoContainer {
        width: 450px;
        height: 300px;
        overflow-y: auto;
        float: left;
        border: 1px solid lightgray;
        margin: 5px;
    }

    .distributionChart {
        width: 450px;
        height: 300px;
        margin: 5px;
        clear: both;
        border: 1px solid lightgray;
    }

    .additionalInfoDiv {
        width: 450px;
        height: 80px;
        margin: 5px;
        clear: both;
        border: 1px solid lightgray;
    }

    #landmarksTableContainer {
        width: 375px;
        height: 350px;
        margin: 5px;
        border: 1px solid lightgray;
        float: left;
        overflow: auto;
    }

    #clustersTableContainer {
        width: 375px;
        height: 350px;
        margin: 5px;
        border: 1px solid lightgray;
        float: left;
        overflow: auto;
    }

    #sinksTableContainer {
        width: 375px;
        height: 350px;
        margin: 5px;
        border: 1px solid lightgray;
        float: left;
        overflow: auto;
    }

    .leafNodeCircle {
        border-radius: 50%;
        width: 12px;
        height: 12px;
        background: #228B22;
        border: 1px solid #000;
        display: inline-block;
    }

    .intermediateNodeCircle {
        border-radius: 50%;
        width: 12px;
        height: 12px;
        background: #7EC0EE;
        border: 1px solid #000;
        display: inline-block;
    }

    .majorSection {
        clear: both;
        float: left;
    }

    .hidden {
        display: none;
    }
</style>

<body>
    <h1>Peel Explorer</h1>
    <p>Parth Parikh, James Abello</p>

    <div>
        <h3>Available Graphs</h3>
        <select id="graphSelect">
        {% for file in graph_files %}
            <option value="{{ file }}">{{ file }}</option>
        {% endfor %}
        </select>
        <button id="loadGraphBtn" type="button">Load Graph</button>
    </div>

    <div style="clear: both;">
        <h3>Overall Statistics</h3>
        <div id="graphStatistics"></div>
    </div>

    <div style="clear: both;">
        <div style="float: left; margin-right: 20px;">
            <h3>Available Hierarchy Trees</h3>
            <select id="treeSelect">
            {% for file in tree_files %}
                <option value="{{ file }}">{{ file }}</option>
            {% endfor %}
            </select>
            <button id="loadTreeBtn" type="button">Load Tree</button>
        </div>
        <div style="float: left; margin-left: 20px;">
            <h3>Save Hierarchy Tree</h3>
            Filename: <input id="saveTreeInput" type="text">
            <button id="saveTreeBtn" type="button" disabled=true>Save Hierarchy Tree</button>
        </div>
    </div>

    <div id="hierarchyTreeSection" class="majorSection hidden">
        <h3>Hierarchy Tree</h3>
        <div>
            <button id="toggleHtreeBtn" type="button">Show Table</button>
        </div>
        <div id="htreeContainer">
            <div class="toggleHtreeContainer">
                <div id="hierarchyTree">
                    <ul id="hierarchyTreeRoot" class="collapsibleList">
                    </ul>
                </div>
            </div>
            <div id="htreeTableDiv" class="toggleHtreeContainer" style="display: none;">
                <input type="text" id="htreeTableSearch" placeholder="Search box" />
                <input type="text" id="htreeTableMinVertices" placeholder="Minimum No. of Vertices" />
                <div class="clusterize" style="height: 400px;">
                    <div id="htreeTablescrollArea" class="clusterize-scroll">
                        <table id="htreeTable">
                            <thead>
                                <tr>
                                    <th>Node Label</th>
                                    <th>|V|</th>
                                    <th>|E|</th>
                                    <th>|V|log|V|</th>
                                    <th>Node Type</th>
                                </tr>
                            </thead>
                            <tbody id="htreeTableContentArea" class="clusterize-content">
                                <tr class="clusterize-no-data">
                                    <td>Click below to load hierarchy table</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <button id="htreeTableBtn" type="button">(Re)Load Hierarchy Table</button>
            </div>
        </div>
        <div id="htreeManipulationControls">
            <div id="treeButtons">
                <div id="displayGraphButtons">
                    <div>
                        <button id="induceNodeSubgraphBtn" type="button">Induce Subgraph</button>
                    </div>
                    <div>
                        <button id="landmarksBtn" type="button">Landmarks</button>
                        <select id="clusteringkMethodSelect">
                        {% for file in clustering_files %}
                            <option value="{{ file }}">{{ file }}</option>
                        {% endfor %}
                        </select>
                        <div style="margin-left: 5px">
                            &#10230;
                            <button id="computeClusterMetagraphBtn" type="button">Compute Metagraph</button>
                        </div>
                    </div>
                    <div>
                        <button id="computeBccTreeBtn" type="button">Compute BCC Tree</button>
                    </div>
                    <div>
                        <button id="saveAdjacencyListBtn" type="button">Save Adjacency List</button>
                    </div>
                </div>
                <br/>
                
                <div id="htreeExplorationButtons">
                    <div>
                        <button id="getNodeChildrenBtn" type="button">Get Node Children</button>
                    </div>
                    <div>
                        <button id="removeChildrenBtn" type="button">Remove Children</button>
                    </div>
                    <br>
                    <div>
                        <button id="computeNodeConnectedComponentsBtn"type="button">Connected Components</button>
                    </div>
                    <div>
                        <button id="computeNodeBiconnectedComponentsBtn" type="button">Biconnected Components</button>
                    </div>
                    <div>
                        <button id="computeNodeEdgePeelBtn" type="button">Edge Peel Decomposition</button>
                    </div>
                    <div>
                        <button id="computeVertexPeelOneBtn" type="button" style="display: none;">Vertex Peel 1</button>
                    </div>
                    <div>
                        <button id="computeKConnectedComponentsBtn" type="button" disabled>k Connected Components</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="htreeNodeChildrenDistributionChart"></div>
    </div>

    <div id="primaryNetwork" class="majorSection hidden">
        <div class="canvasContainers">
            <h3>Network</h3>
            <div style="float: left;">
                <div class="networkCanvasContainer">
                    <div id="networkCanvas"></div>
                </div>
                <div>
                    <div>
                        <button id="stopSimulationBtn" type="button">Pause Simulation</button>
                        <button id="toggleEdgesBtn" type="button">Toggle Edges</button>
                        <button id="toggleArrowsBtn" type="button">Toggle Arrows</button>
                        <button id="resetEdgeColorsBtn" type="button">Reset Edge Colors</button>
                    </div>
                    <div>
                        <button id="highlightBfsTreeBtn" type="button">Highlight BFS Tree</button>
                        <button id="highlightSpineAndNetBtn" type="button">Highlight Net</button>
                        <button id="highlightOnlySpine" type="button">Highlight Spine</button>
                        <button id="highlightLandmarksPlusOneHopBtn" type="button">Landmark Neighborhood</button>
                        <button id="overlaySpineBtn" type="button">Overlay Spine</button>
                    </div>
                </div>
                <div id="dev-ops"></div>
            </div>
            <div style="float: left;">
                <div id="nodeInfoContainer">
                    <div id="nodeInfo"></div>
                </div>
                <div id="degreeDistChart" class="distributionChart"></div>
                <div id="landmarksInfoDiv" class="additionalInfoDiv"></div>
            </div>
        </div>
    </div>

    <div id="clusterDescriptions" style="display: none;">
        <div id="landmarksTableContainer">
            <table id="landmarksTable" style="table-layout: fixed;">
                <thead>
                    <tr>
                        <th>Landmark ID</th>
                        <th>Vertex Label</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody id="landmarksTableContentArea" class="clusterize-content">
                    <tr class="clusterize-no-data">
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="clustersTableContainer">
            <table id="clustersTable" style="table-layout: fixed;">
                <thead>
                    <tr>
                        <th>Vertex Label</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody id="clustersTableContentArea" class="clusterize-content">
                    <tr class="clusterize-no-data">
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
         <div id="sinksTableContainer">
            <table id="sinksTable" style="table-layout: fixed;">
                <thead>
                    <tr>
                        <th>Sink Label</th>
                        <th>Descr.</th>
                        <th>Depth</th>
                        <th>In-Degree</th>
                    </tr>
                </thead>
                <tbody id="sinksTableContentArea" class="clusterize-content">
                    <tr class="clusterize-no-data">
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div> 
        <div style="clear: both;">
            <button id="getIntraClusterDescriptionsBtn" type="button">Get Intra-cluster Descriptions</button>
            <button id="getSinkDescriptionsBtn" type="button">Get Sink Descriptions</button>
        </div>
    </div>

    <div id="bccTreeContainer" class="majorSection hidden">
        <div class="canvasContainers">
            <h3>BCC Tree</h3>
            <div style="float: left;">
                <div class="networkCanvasContainer">
                    <div id="bccTreeCanvas"></div>
                </div>
            </div>
            <div style="float: left;">
                <div id="apDegreeDistChart" class="distributionChart"></div>
                <div id="bccSizeDistChart" class="distributionChart"></div>
                <div id="bccTreeInfoDiv" class="additionalInfoDiv"></div>
            </div>
        </div>
    </div> 

</body>

<!-- TODO: Standardize script links -->
<script src="{{url_for('static', filename='js/jquery-3.2.1.min.js')}}"></script>
<script src="/static/js/vis.min.js"></script>
<link href="/static/css/vis.min.css" rel="stylesheet" type="text/css" />
<script src="/static/js/main-network-view.js"></script>
<script src="/static/js/renderjson.js"></script>
<script src="/static/js/CollapsibleLists.js"></script>
<script src="/static/js/clusterize.min.js"></script>
<script src="/static/js/highcharts.js"></script>
<script src="/static/js/exporting.js"></script>

<script>
    var isGraphLoaded = false,
        isHtreeLoaded = false;

    var edgesShown = true;
    $('#loadGraphBtn').on('click', function(e) {
        $('#graphSelect').prop('disabled', true);
        $('#loadGraphBtn').prop('disabled', true);
        $('#treeSelect').prop('disabled', true);
        $('#loadTreeBtn').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/load-graph',
            data: {
                filename: $('#graphSelect').val()
            },
            success: function(response) {
                $("#graphStatistics").html(response);
                isGraphLoaded = true;
                $('#primaryNetwork').removeClass('hidden');
                if (isHtreeLoaded) {
                    $('#hierarchyTreeSection').removeClass('hidden');
                }
            },
            complete: function() {
                $('#graphSelect').prop('disabled', false);
                $('#loadGraphBtn').prop('disabled', false);
                $('#treeSelect').prop('disabled', false);
                $('#loadTreeBtn').prop('disabled', false);
            }
        });
    });

    $('#loadTreeBtn').on('click', function(e) {
        $('#graphSelect').prop('disabled', true);
        $('#loadGraphBtn').prop('disabled', true);
        $('#treeSelect').prop('disabled', true);
        $('#loadTreeBtn').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/load-tree',
            data: {
                filename: $('#treeSelect').val()
            },
            success: function(response) {
                $('#hierarchyTreeRoot').html(
                    '<li><span class="node" data-value="root">Root</span></li>'
                );
                CollapsibleLists.applyTo($('#hierarchyTreeRoot')[0]);
                $('#saveTreeBtn').prop('disabled', false);
                isHtreeLoaded = true;
                $('#hierarchyTreeSection').removeClass('hidden');
                if (isGraphLoaded) {
                    $('#primaryNetwork').removeClass('hidden');
                }
            },
            complete: function() {
                $('#graphSelect').prop('disabled', false);
                $('#loadGraphBtn').prop('disabled', false);
                $('#treeSelect').prop('disabled', false);
                $('#loadTreeBtn').prop('disabled', false);
            }
        });
    });

    $('#saveTreeBtn').on('click', function(e) {
        $('#saveTreeBtn').prop('disabled', true);
        var filename = $('#saveTreeInput').val();
        if (!filename) {
            alert('Empty filename');
            return;
        }
        $.ajax({
            type: 'GET',
            url: '/save-tree',
            data: {
                filename: filename
            },
            success: function(resposne) {
                alert(resposne['msg']);
            },
            complete: function() {
                $('#saveTreeBtn').prop('disabled', false);
            }
        });

    });

    $('#toggleHtreeBtn').click(function() {
        $('#htreeContainer > .toggleHtreeContainer').toggle();
        $(this).text(function(i, text) {
            return text === "Show Table" ? "Show Tree" : "Show Table";
        });
    });

    $('#stopSimulationBtn').click(function(e) {
        e.preventDefault();
        try {
            network.stopSimulation();
        } catch(e) {
            if (e instanceof ReferenceError) {
                // variable network does not exist
            } else if (e instanceof TypeError) {
                // network is not what we think it is
            }
        }
    });

    $('#highlightBfsTreeBtn').click(function(e) {
        e.preventDefault();
        var selectedNodes = network.getSelectedNodes();
        if (selectedNodes.length !== 1) {
            // 0 or more than 1 nodes are selected
            return;
        }
        $('#highlightBfsTreeBtn').prop('disabled', true);
        var rootNodeID = selectedNodes[0];
        $.ajax({
            type: 'GET',
            url: '/bfs-tree',
            data: {
                rootNodeID: rootNodeID
            },
            success: function(response) {
                var updateArray = [];
                for (var edgeID in allEdges) {
                    if (allEdges.hasOwnProperty(edgeID)) {
                        var edge = allEdges[edgeID];
                        if (response.hasOwnProperty(edgeID)) {
                            edge['color'] = {'color': 'red'};
                            edge['selectionWidth'] = 2;
                        } else {
                            edge['color'] = {'color': 'rgba(200,200,200,0.5)'};
                            edge['selectionWidth'] = undefined;
                        }
                        updateArray.push(edge);
                    }
                }
                edgesDataset.update(updateArray);

                updateArray = [];
                for (var nodeID in allNodes) {
                    var node = allNodes[nodeID];
                    if (nodeID == rootNodeID) {
                        node['color'] = undefined;
                    } else {
                        node['color'] = 'rgba(200,200,200,0.5)';
                    }
                    updateArray.push(node);
                }
                nodesDataset.update(updateArray);
            },
            complete: function() {
                $('#highlightBfsTreeBtn').prop('disabled', false);
            }
        });
    });

    $('#toggleEdgesBtn').click(function(e) {
        e.preventDefault();
        var updateArray = [];
        var displayEdges = !edgesShown;
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            edge['hidden'] = displayEdges;
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
        edgesShown = !edgesShown;
    });

    $('#toggleArrowsBtn').click(function(e) {
        e.preventDefault();
        toggleArrows();
    });

    $('#resetEdgeColorsBtn').click(function(e) {
        e.preventDefault();
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            edge['hidden'] = false;
            edge['color'] = {'inherit': 'from', 'opacity': 1.0};
            edge['width'] = MIN_EDGE_WIDTH;
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
    });

    $('#overlaySpineBtn').click(function(e) {
        e.preventDefault();
        var spineLength = 0;
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            if (!edge.hasOwnProperty('category')) {
                alert('Edges are not annotated with spine categories.');
                return;
            }
            edge['hidden'] = false;
            if (edge['category'] === 'spine') {
                edge['color'] = {'color': 'rgba(255,0,0,1.0)'};
                edge['width'] = MAX_EDGE_WIDTH;
                spineLength++;
            } else if (edge['category'] === 'branch') {
                edge['color'] = {'color': 'rgba(0,0,0,1.0)'};
                edge['width'] = Math.round(0.75 * MAX_EDGE_WIDTH);
            } else {
                // edge['color'] = {'color': 'rgba(200,200,200,0.5)'};
                edge['color'] = {'inherit': 'from', 'opacity': 0.60};
                edge['width'] = MIN_EDGE_WIDTH;
            }
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
        $('#landmarksInfoDiv').html('Spine Length: ' + spineLength);
    });

    $('#highlightOnlySpine').click(function(e) {
        e.preventDefault();
        var spineLength = 0;
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            if (!edge.hasOwnProperty('category')) {
                alert('Edges are not annotated with spine categories.');
                return;
            }
            edge['hidden'] = false;
            if (edge['category'] === 'spine') {
                edge['color'] = {'color': 'rgba(255,0,0,1.0)'};
                edge['width'] = MAX_EDGE_WIDTH;
                spineLength++;
            } else {
                edge['width'] = MIN_EDGE_WIDTH;
                edge['hidden'] = true;
            }
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
        $('#landmarksInfoDiv').html('Spine Length: ' + spineLength);
    });

    $('#highlightSpineAndNetBtn').click(function(e) {
        e.preventDefault();
        var spineLength = 0;
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            if (!edge.hasOwnProperty('category')) {
                alert('Edges are not annotated with spine categories.');
                return;
            }
            edge['hidden'] = false;
            if (edge['category'] === 'spine') {
                edge['color'] = {'color': 'rgba(255,0,0,1.0)'};
                edge['width'] = MAX_EDGE_WIDTH;
                spineLength++;
            } else if (edge['category'] === 'branch') {
                edge['color'] = {'color': 'rgba(0,0,0,1.0)'};
                edge['width'] = Math.round(0.75 * MAX_EDGE_WIDTH);
            } else {
                // edge['color'] = {'color': 'rgba(200,200,200,0.5)'};
                // edge['color'] = {'inherit': 'from', 'opacity': 0.60};
                // edge['width'] = MIN_EDGE_WIDTH;
                edge['hidden'] = true;
            }
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
        $('#landmarksInfoDiv').html('Spine Length: ' + spineLength);
    });

    $('#highlightLandmarksPlusOneHopBtn').click(function(e) {
        e.preventDefault();
        var spineLength = 0;
        var landmarkNodes = {};
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            if (node['shape'] === 'star') {
                landmarkNodes[node['id']] = 1;
            }
        }
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            if (!edge.hasOwnProperty('category')) {
                alert('Edges are not annotated with spine categories.');
                return;
            }
            edge['hidden'] = false;
            if (edge['category'] === 'spine') {
                edge['color'] = {'color': 'rgba(255,0,0,1.0)'};
                edge['width'] = MAX_EDGE_WIDTH;
                spineLength++;
            } else if (edge['category'] === 'branch') {
                edge['color'] = {'color': 'rgba(0,0,0,1.0)'};
                edge['width'] = Math.round(0.75 * MAX_EDGE_WIDTH);
            } else {
                var srcNodeID = edge['from'];
                var tarNodeID = edge['to'];
                if (!landmarkNodes.hasOwnProperty(srcNodeID) &&
                        !landmarkNodes.hasOwnProperty(tarNodeID)) {
                    edge['hidden'] = true;
                    edge['width'] = Math.round(0.15 * MAX_EDGE_WIDTH);
                }
            }
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
        $('#landmarksInfoDiv').html('Spine Length: ' + spineLength);
    });

    $('body').on('click', 'span.node', function(e) {
        e.preventDefault();
        var $nodes = $('span.node');
        $nodes.removeClass('selected');
        $(this).addClass('selected');
    });

    $('body').on('click', '#htreeTable tr', function(e) {
        e.preventDefault();
        $(this).addClass('selected').siblings().removeClass('selected');
    });

    $('body').on('click', '#landmarksTable tr', function(e) {
        e.preventDefault();
        if ($(this).hasClass('selected')) {
            $(this).removeClass('selected');
        } else {
            $(this).addClass('selected').siblings().removeClass('selected');
        }
    });

    $('body').on('click', '#clustersTable tr', function(e) {
        e.preventDefault();
        if ($(this).hasClass('selected')) {
            $(this).removeClass('selected');
        } else {
            $(this).addClass('selected').siblings().removeClass('selected');
        }
        var vertex_label = $(this).children('td').eq(0).text();

        var updateArray = [];
        var selectedNode = null;
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            if (node['label'] == vertex_label) {
                node['color'] = undefined;
                selectedNode = node;
            } else {
                node['color'] = 'rgba(200,200,200,0.5)';
            }
            updateArray.push(node);
        }
        nodesDataset.update(updateArray);
        highlightActive = true;
        fetch_node_info(selectedNode['id']);
    });

    $('body').on('click', '#sinksTable tr', function(e) {
        e.preventDefault();
        if ($(this).hasClass('selected')) {
            $(this).removeClass('selected');
        } else {
            $(this).addClass('selected').siblings().removeClass('selected');
        }
        var vertex_label = $(this).children('td').eq(0).text();

        var updateArray = [];
        var selectedNode = null;
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            if (node['label'] == vertex_label) {
                node['color'] = undefined;
                selectedNode = node;
            } else {
                node['color'] = 'rgba(200,200,200,0.5)';
            }
            updateArray.push(node);
        }
        nodesDataset.update(updateArray);
        highlightActive = true;
        fetch_node_info(selectedNode['id']);
    });

    $('#getNodeChildrenBtn').on('click', function(e) {
        var node = $("#hierarchyTree li>span.selected");
        var fullyQualifiedLabel = node.attr('data-value');
        $('#getNodeChildrenBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/get-hnode-children',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                // populate hierarchy tree nodes
                node.nextAll().remove();
                node.after(response['tree_nodes_html']);

                // make children size distribution chart
                // TODO: Switch between edge distr and node distr
                var titleText = 'Tree Node Children Size Distribution';
                var node_info = response['node_info'];
                var chartData = [];
                for (var i = 0; i < node_info.length; i++) {
                    chartData.push({
                        name: node_info[i]['short_label'],
                        data: [node_info[i]['num_vertices']]
                    });
                }
                chartData.reverse();

                drawTreeNodeChildrenDistributionChart(
                    chartData,
                    'htreeNodeChildrenDistributionChart',
                    titleText
                );
            },
            complete: function() {
                $('#getNodeChildrenBtn :button').prop('disabled', false);
            }
        });
    });

    $('#removeChildrenBtn').on('click', function(e) {
        var node = $("#hierarchyTree li>span.selected");
        var fullyQualifiedLabel = node.attr('data-value');
        $('#removeChildrenBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/remove-hnode-children',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                // TODO: Do something here...
                console.log(response);
            },
            complete: function() {
                $('#getNodeChildrenBtn :button').prop('disabled', false);
            }
        });
    });

    $('#induceNodeSubgraphBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        $('#clustersTableContentArea').empty();
        $('#landmarksTableContentArea').empty();
        $('#sinksTableContentArea').empty();

        var fullyQualifiedLabel = node.attr('data-value');
        $('#induceNodeSubgraphBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/induce-hnode-subgraph',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                var vis_data = response['vis_data'];                
                nodesDataset = new vis.DataSet(vis_data['nodes']);
                edgesDataset = new vis.DataSet(vis_data['edges']);
                redrawAll('networkCanvas');
                degreeDistribution();
            },
            complete: function() {
                $('#induceNodeSubgraphBtn :button').prop('disabled', false);
                // $('#bccTreeContainer').css('display', 'none');
                $('#bccTreeContainer').addClass('hidden');
            }
        });
    });

    $('#landmarksBtn').click(function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        $('#clustersTableContentArea').empty();
        $('#landmarksTableContentArea').empty();
        $('#sinksTableContentArea').empty();

        var fullyQualifiedLabel = node.attr('data-value');
        $('#landmarksBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/cluster-by-landmarks',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel,
                filename: $('#clusteringkMethodSelect').val()
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                var vis_data = response['vis_data'];
                // makes landmarks bigger
                var nodes = remapNodeSizes(vis_data['nodes'])
                nodesDataset = new vis.DataSet(nodes);
                edgesDataset = new vis.DataSet(vis_data['edges']);

                if (vis_data['nodes'].length > 2200) {
                    alert('Graph is too large to visualize');
                } else {
                    redrawAll('networkCanvas');
                }
                degreeDistribution();
                getLandmarkClusters();
                appendLandmarkClusters(fullyQualifiedLabel,
                                       response['cluster_assignment'],
                                       node);
            },
            complete: function() {
                $('#landmarksBtn :button').prop('disabled', false);
                $('#clusterDescriptions').show();
                // $('#bccTreeContainer').css('display', 'block');
                $('#bccTreeContainer').removeClass('hidden');
            }
        });
    });

    $('#computeClusterMetagraphBtn').click(function(e) {
        e.preventDefault();
        var node = '',
            fullyQualifiedLabel = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            // NOTE: This function available only through tree view, not table
            // node = $('#htreeTableDiv tr.selected');
            return;
        }
        fullyQualifiedLabel = node.attr('data-value');
        $('#computeClusterMetagraphBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/compute-metagraph',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                var vis_data = response['vis_data'];
                var nodes = remapNodeSizes(vis_data['nodes'])
                var edges = vis_data['edges'];
                nodesDataset = new vis.DataSet(nodes);
                edgesDataset = new vis.DataSet(edges);

                // TODO: Temporarily borrow bccTreeCanvas div
                redrawAll('bccTreeCanvas');
            },
            complete: function() {
                $('#computeClusterMetagraphBtn :button').prop('disabled', false);
            }
        });
    })

    $('#computeBccTreeBtn').click(function(e) {
        e.preventDefault();
        var node = '',
            fullyQualifiedLabel = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        fullyQualifiedLabel = node.attr('data-value');

        $('#computeBccTreeBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/compute-bcc-tree',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                var vis_data = response['vis_data'];
    
                // makes landmarks bigger
                var nodes = remapNodeSizes(vis_data['nodes'])
                var edges = vis_data['edges'];
                nodesDataset = new vis.DataSet(nodes);
                edgesDataset = new vis.DataSet(edges);

                // draw bcc tree
                if (vis_data['nodes'].length > 2400) {
                    alert('Graph is too large to visualize');
                } else {
                    redrawAll('bccTreeCanvas');
                }

                // draw charts
                drawChart(
                    {
                        'x': response['ap_deg_bins'],
                        'y': response['ap_deg_counts']
                    },
                    'AP Degree',
                    'Articulation Point Degree Distribution',
                    'apDegreeDistChart',
                    true
                );
                drawChart(
                    {
                        'x': response['bcc_size_bins'],
                        'y': response['bcc_size_counts']
                    },
                    'Biconnected Component Size',
                    'BCC Size Distribution',
                    'bccSizeDistChart',
                    true
                );

                // additional bcc tree info
                // bccTreeInfoDiv
                var num_ap = response['ap_deg_counts']
                    .reduce(function(a, b) { return a + b; }, 0);

                var num_bcc_metanodes = response['bcc_size_counts']
                    .reduce(function(a, b) { return a + b; }, 0);

                $('#bccTreeInfoDiv').html(
                    'BCC Tree Statistics -- <br>' +
                    'Nodes: ' + nodes.length + ' | Edges: ' + edges.length + '<br>' +
                    '&emsp;Articulation Points: ' + num_ap + '<br>' +
                    '&emsp;BCC Metanodes: ' + num_bcc_metanodes
                )

                // $('#bccTreeContainer').css('display', 'block');
                $('#bccTreeContainer').removeClass('hidden');
            },
            complete: function() {
                $('#computeBccTreeBtn :button').prop('disabled', false);
            } 
        })
    })

    $('#saveAdjacencyListBtn').click(function(e) {
        e.preventDefault();
        var node = '',
            fullyQualifiedLabel = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        fullyQualifiedLabel = node.attr('data-value');

        $('#saveAdjacencyListBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/save-adjacency-list',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                }
            },
            complete: function() {
                $('#saveAdjacencyListBtn :button').prop('disabled', false);
            }
        });
    });

    $('#getIntraClusterDescriptionsBtn').click(function(e) {
        var groupID = parseInt($('#landmarksTable tr.selected td:nth-child(1)').text());
        var networkGroups = network['groups']['groups'];
        var rgbMap = hexToRgb(networkGroups[groupID]['color']['background']);
        var rgbColorString = toRgbColorString(rgbMap);
        // var rgbColorString = "rgba(" + rgbColor['r'] + ", " + 
        //                                rgbColor['g'] + ", " + 
        //                                rgbColor['b'] + ", " +
        //                                0.50 + ");";

        // TODO: SORT BY DEGREE
        var intraClusterNodes = [];
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            if (node['group'] == groupID) {
                intraClusterNodes.push({
                    'id': node['id'],
                    'label': node['label']
                })
            }
        }
        
        $.ajax({
            type: 'GET',
            url: '/get-intracluster-summary',
            data: {
                nodes: JSON.stringify(intraClusterNodes)
            },
            success: function(response) {
                if (response.hasOwnProperty('summary')) {
                    console.log(response['summary']);
                }
                var rows = [];
                for (var icNode in intraClusterNodes) {
                    var node = intraClusterNodes[icNode];
                    rows.push('<tr style="background-color: ' + rgbColorString + '" data-value="' + node['id'] + '">' +
                                '<td>' + node['label'] + '</td>' +
                                '<td>' + response['nodes'][node['label']] + '</td>' +
                                '</tr>');
                }
                var clusterize = new Clusterize({
                    rows: rows,
                    scrollId: 'clustersTableContainer',
                    contentId: 'clustersTableContentArea'
                });
            },
            complete: function() { }
        });
    });

    $('#getSinkDescriptionsBtn').click(function(e) {
        var sinks = [];
        nodesLoop:
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            var incidentEdges = network.getConnectedEdges(nodeID);
            for (var edgeNum in incidentEdges) {
                if (edgesDataset.get(incidentEdges[edgeNum])['from'] == nodeID) {
                    continue nodesLoop;
                }
            }
            sinks.push({
                'id': node['id'],
                'label': node['label'],
                'group': node['group'],
                'inDegree': incidentEdges.length,
            });
        }

        $.ajax({
            type: 'GET',
            url: '/get-sink-info',
            data: {
                nodes: JSON.stringify(sinks)
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                var networkGroups = network['groups']['groups'];
                var rows = [];
                for (var sinkNum in sinks) {
                    var sink = sinks[sinkNum];
                    var rgbMap = hexToRgb(networkGroups[sink['group']]['color']['background']);
                    var rgbColorString = toRgbColorString(rgbMap);
                    var resp = response[sink['label']];
                    rows.push('<tr style="background-color: ' + rgbColorString + '" data-value="' + sink['id'] + '">' +
                                '<td>' + sink['label'] + '</td>' +
                                '<td>' + resp['elements'] + '</td>' +
                                '<td>' + resp['depth'] + '</td>' +
                                '<td>' + sink['inDegree'] + '</td>' +
                                '</tr>');
                }
                var clusterize = new Clusterize({
                    rows: rows,
                    scrollId: 'sinksTableContainer',
                    contentId: 'sinksTableContentArea'
                });

                toggleArrows();
            },
            complete: function() { }
        });
    });

    $('#htreeTable tr').click(function() {
        $(this).addClass('selected').siblings().removeClass('selected');
    });

    $('#htreeTableBtn').on('click', function(e) {
        $('#htreeTableBtn :button').prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/get-hierarchy-tree',
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }

                var rows = [],
                    search = $('#htreeTableSearch')[0]
                    vfilt = $('#htreeTableMinVertices')[0];

                var colorPicker = function(num_vertices) {
                    var color = 'rgba(0, 0, 0, 0);';
                    num_vertices = parseInt(num_vertices);
                    if (num_vertices >=  65536) {
                        color = 'rgba(135, 0, 0, 0.7);';
                    } else if (num_vertices >= 16384) {
                        color = 'rgba(165, 0, 0, 0.7);';
                    } else if (num_vertices >= 4096) {
                        color = 'rgba(195, 0, 0, 0.5);';
                    } else if (num_vertices >= 1024) {
                        color = 'rgba(225, 0, 0, 0.3);';
                    } else if (num_vertices >= 256) {
                        color = 'rgba(255, 0, 0, 0.1);';
                    } else {
                        color = 'rgba(0, 0, 0, 0);';
                    }
                    return color;
                }

                var nodes = response['nodes'];
                for(var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    var color = colorPicker(node['num_vertices']);
                    rows.push({
                        values: [node['label'],
                                 node['num_vertices'],
                                 node['num_edges'],
                                 node['vlogv'],
                                 node['node_type']
                                ],
                        markup: '<tr style="background-color: ' + color + '" data-value="' + node['label'] + '">' +
                            '<td>' + node['label'] + '</td>' +
                            '<td>' + node['num_vertices'] + '</td>' +
                            '<td>' + node['num_edges'] + '</td>' +
                            '<td>' + node['vlogv'] + '</td>' +
                            '<td>' + node['node_type'] + '</td>' +
                            '</tr>',
                        active: true
                    });
                }

                var filterRows = function(rows) {
                    var results = [];
                    for (var i = 0; i < rows.length; i++) {
                        if (rows[i].active) {
                            results.push(rows[i].markup)
                        }
                    }
                    return results;
                }

                var clusterize = new Clusterize({
                    rows: filterRows(rows),
                    scrollId: 'htreeTablescrollArea',
                    contentId: 'htreeTableContentArea'
                });

                var onSearch = function() {
                    for (var i = 0; i < rows.length; i++) {
                        var suitable = false;
                        for (var j = 0; j < rows[i].values.length; j++) {
                            if (rows[i].values[j].toString().indexOf(search.value) + 1) {
                                suitable = true;
                            }
                        }
                        rows[i].active = suitable;
                    }
                    clusterize.update(filterRows(rows));
                }

                var onVfilt = function() {
                    var threshold = parseFloat(vfilt.value);
                    for (var i = 0; i < rows.length; i++) {
                        var suitable = false;
                        var num_vertices = parseInt(rows[i].values[1]);
                        if (num_vertices > threshold) {
                            suitable = true;
                        }
                        rows[i].active = suitable;
                    }
                    clusterize.update(filterRows(rows));
                }


                search.oninput = onSearch;
                vfilt.oninput = onVfilt;
            },
            complete: function() {
                $('#htreeTableBtn :button').prop('disabled', false);
            }
        });
    });

    $('#computeNodeConnectedComponentsBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        var operation = 'connected_components';
        var btn = $('#computeNodeBiconnectedComponentsBtn :button')
        decompose_by_operation(node, operation, btn);
    });

    $('#computeNodeBiconnectedComponentsBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        var operation = 'biconnected_components';
        var btn = $('#computeNodeBiconnectedComponentsBtn :button')
        decompose_by_operation(node, operation, btn);
    });

    $('#computeNodeEdgePeelBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        var operation = 'edge_peel';
        var btn = $('#computeNodeEdgePeelBtn :button')
        decompose_by_operation(node, operation, btn);
    });

    $('#computeVertexPeelOneBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        var operation = 'peel_one';
        var btn = $('#computeVertexPeelOneBtn :button')
        decompose_by_operation(node, operation, btn);
    });

    $('#computeKConnectedComponentsBtn').on('click', function(e) {
        var node = '';
        if ($('#htreeTableDiv').css('display') == 'none') {
            node = $("#hierarchyTree li>span.selected");
        } else {
            node = $('#htreeTableDiv tr.selected');
        }
        var operation = 'k_connected_components';
        var btn = $('#computeKConnectedComponentsBtn :button')
        decompose_by_operation(node, operation, btn);
    });

    function decompose_by_operation(node, operation, btn) {
        var fullyQualifiedLabel = node.attr('data-value');
        btn.prop('disabled', true);
        $.ajax({
            type: 'GET',
            url: '/decompose-by-operation',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel,
                operation: operation
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    alert(response['msg']);
                    return;
                }
                node.after(response);
            },
            complete: function() {
                btn.prop('disabled', false);
            }
        })
    }

    function degreeDistribution() {
        var degrees = [];
        for (var nodeID in allNodes) {
            degrees.push(network.getConnectedNodes(nodeID).length);
        }
        degrees.sort(function(a, b) {
            return a - b;  
        });

        var bins = [], counts = [], prev;
        for (var i = 0; i < degrees.length; i++) {
            if (degrees[i] !== prev) {
                bins.push(degrees[i]);
                counts.push(1);
            } else {
                counts[counts.length - 1]++;
            }
            prev = degrees[i];
        }

        drawChart(
            {'x': bins, 'y': counts},
            'Degree',
            'Degree Distribution',
            'degreeDistChart',
            true
        );
    }

    function drawChart(data, seriesText, titleText, container, enableLegend=false) {
        Highcharts.chart(container, {
            chart: {
                type: 'column',
                zoomType: 'x'
            },
            title: {
                text: titleText
            },
            xAxis: {
                categories: data['x'],
                crosshair: true
            },
            yAxis: {
                min: 0,
                title: {
                    text: 'Count'
                }
            },
            tooltip: {
                formatter: function() {
                    return '<b>' + this.y + '</b>'
                }
            },
            plotOptions: {
                column: {
                    pointPadding: 0.2,
                    borderWidth: 0
                }
            },
            legend: {
                enabled: enableLegend
            },
            series: [{
                name: seriesText,
                data: data['y']
            }]
        });
    }

    function drawTreeNodeChildrenDistributionChart(data, container, titleText,) {
        Highcharts.chart(container, {
            chart: {
                type: 'bar',
                zoomType: 'y'
            },
            title: {
                text: titleText
            },
            xAxis: {
                visible: false
            },
            yAxis: {
                min: 0,
                title: {
                    text: 'Cumulative'
                }
            },
            legend: {
                enabled: false
            },
            plotOptions: {
                series: {
                    stacking: 'normal'
                },
                bar: {
                    dataLabels: {
                        enabled: true,
                        distance : -50,
                        formatter: function() {
                            var dlabel = this.series.name + '<br/>';
                            dlabel += Math.round(this.percentage*100)/100 + ' %';
                                return dlabel
                        },
                        style: {
                            color: 'white',
                        },
                    },
                    
                },
            },
            series: data
        });
    }

    function getLandmarkClusters() {
        var networkGroups = network['groups']['groups'];
        var clusters = {};
        for (var nodeID in allNodes) {
            var node = allNodes[nodeID];
            var group = node['group'];
            if (!clusters.hasOwnProperty(group)) {
                clusters[group] = {};
                clusters[group]['nodes'] = [];
                clusters[group]['landmark'] = '';
            }
            clusters[group]['nodes'].push({
                'id': node['id'],
                'label': node['label']
            });
            // NOTE: shape == star denotes landmark
            if (node['shape'] === 'star') {
                clusters[group]['landmark'] = {
                    'id': node['id'],
                    'label': node['label']
                }
            }
        }
        $.ajax({
            type: 'GET',
            url: '/landmark-regions',
            data: {
                clusters: JSON.stringify(clusters)
            },
            success: function(response) {
                var rows = [];
                for (var groupID in clusters) {
                    var landmarkLabel = clusters[groupID]['landmark']['label'];
                    var landmarkID = clusters[groupID]['landmark']['id'];
                    var rgbColor = hexToRgb(networkGroups[groupID]['color']['background']);
                    var rgbColorString = "rgba(" + rgbColor['r'] + ", " + 
                                                   rgbColor['g'] + ", " + 
                                                   rgbColor['b'] + ", " +
                                                   0.50 + ");";
                    rows.push('<tr style="background-color: ' + rgbColorString + '" data-value="' + landmarkID + '">' +
                                '<td>' + groupID + '</td>' +
                                '<td>' + landmarkLabel + '</td>' +
                                '<td>' + response[landmarkLabel] + '</td>' +
                                '</tr>');
                }

                var clusterize = new Clusterize({
                    rows: rows,
                    scrollId: 'landmarksTableContainer',
                    contentId: 'landmarksTableContentArea'
                });
            },
            complete: function() { }
        });
    }

    function appendLandmarkClusters(fullyQualifiedLabel, cluster_assignment, node) {
        $.ajax({
            type: 'POST',
            url: '/append-landmark-clusters',
            data: {
                fullyQualifiedLabel: fullyQualifiedLabel,
                cluster_assignment: JSON.stringify(cluster_assignment)
            },
            success: function(response) {
                if (response.hasOwnProperty('msg')) {
                    // alert(response['msg']);
                    console.log(response['msg']);
                    return;
                }
                node.after(response);
            },
            complete: function() { }
        });
    }

    function toggleArrows() {
        var updateArray = [];
        for (var edgeID in allEdges) {
            var edge = allEdges[edgeID];
            if (edge.hasOwnProperty('arrows')) {
                delete edge['arrows'];
            } else {
                edge['arrows'] = 'to';
            }
            updateArray.push(edge);
        }
        edgesDataset.update(updateArray);
    }

    /*
    source: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
    */
    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    function toRgbColorString(rgbMap, opacity=0.50) {
        var rgbColorString = "rgba(" + rgbMap['r'] + ", " + 
                                       rgbMap['g'] + ", " + 
                                       rgbMap['b'] + ", " +
                                       opacity + ");";
        return rgbColorString;
    }
</script>

</html>